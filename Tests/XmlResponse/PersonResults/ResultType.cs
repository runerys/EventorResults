//
// ResultType.cs
//
// This file was generated by XMLSpy 2006sp2 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace PersonResults
{
	public class ResultType : Altova.Xml.Node
	{
		#region Forward constructors

		public ResultType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public ResultType(XmlNode node) : base(node) { SetCollectionParents(); }
		public ResultType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public ResultType(Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ResultId" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ResultId", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "BibNumber" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "BibNumber", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "CCardId" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "CCardId", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "StartTime" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "StartTime", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new StartTimeType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "FinishTime" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "FinishTime", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new FinishTimeType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "Time" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "Time", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "TimeDiff" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "TimeDiff", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ResultPosition" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ResultPosition", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "CompetitorStatus" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "CompetitorStatus", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new CompetitorStatusType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ModifyDate" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ModifyDate", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new ModifyDateType(DOMNode).AdjustPrefix();
			}

		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.Element, "", "ModifiedBy" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.Element, "", "ModifiedBy", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, true);
				new ModifiedByType(DOMNode).AdjustPrefix();
			}
		}



		#region ResultId accessor methods
		public static int GetResultIdMinCount()
		{
			return 1;
		}

		public static int ResultIdMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetResultIdMaxCount()
		{
			return 1;
		}

		public static int ResultIdMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetResultIdCount()
		{
			return DomChildCount(NodeType.Element, "", "ResultId");
		}

		public int ResultIdCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ResultId");
			}
		}

		public bool HasResultId()
		{
			return HasDomChild(NodeType.Element, "", "ResultId");
		}

		public ResultIdType NewResultId()
		{
			return new ResultIdType();
		}

		public ResultIdType GetResultIdAt(int index)
		{
			return new ResultIdType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ResultId", index)));
		}

		public XmlNode GetStartingResultIdCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ResultId" );
		}

		public XmlNode GetAdvancedResultIdCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ResultId", curNode );
		}

		public ResultIdType GetResultIdValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new ResultIdType( curNode.InnerText );
		}


		public ResultIdType GetResultId()
		{
			return GetResultIdAt(0);
		}

		public ResultIdType ResultId
		{
			get
			{
				return GetResultIdAt(0);
			}
		}

		public void RemoveResultIdAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ResultId", index);
		}

		public void RemoveResultId()
		{
			while (HasResultId())
				RemoveResultIdAt(0);
		}

		public void AddResultId(ResultIdType newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "ResultId", newValue.ToString());
		}

		public void InsertResultIdAt(ResultIdType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ResultId", index, newValue.ToString());
		}

		public void ReplaceResultIdAt(ResultIdType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ResultId", index, newValue.ToString());
		}
		#endregion // ResultId accessor methods

		#region ResultId collection
        public ResultIdCollection	MyResultIds = new ResultIdCollection( );

        public class ResultIdCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ResultIdEnumerator GetEnumerator() 
			{
				return new ResultIdEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ResultIdEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public ResultIdEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ResultIdCount );
			}
			public ResultIdType  Current 
			{
				get 
				{
					return(parent.GetResultIdAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ResultId collection

		#region BibNumber accessor methods
		public static int GetBibNumberMinCount()
		{
			return 0;
		}

		public static int BibNumberMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetBibNumberMaxCount()
		{
			return 1;
		}

		public static int BibNumberMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBibNumberCount()
		{
			return DomChildCount(NodeType.Element, "", "BibNumber");
		}

		public int BibNumberCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "BibNumber");
			}
		}

		public bool HasBibNumber()
		{
			return HasDomChild(NodeType.Element, "", "BibNumber");
		}

		public SchemaString NewBibNumber()
		{
			return new SchemaString();
		}

		public SchemaString GetBibNumberAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "BibNumber", index)));
		}

		public XmlNode GetStartingBibNumberCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "BibNumber" );
		}

		public XmlNode GetAdvancedBibNumberCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "BibNumber", curNode );
		}

		public SchemaString GetBibNumberValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetBibNumber()
		{
			return GetBibNumberAt(0);
		}

		public SchemaString BibNumber
		{
			get
			{
				return GetBibNumberAt(0);
			}
		}

		public void RemoveBibNumberAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "BibNumber", index);
		}

		public void RemoveBibNumber()
		{
			while (HasBibNumber())
				RemoveBibNumberAt(0);
		}

		public void AddBibNumber(SchemaString newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "BibNumber", newValue.ToString());
		}

		public void InsertBibNumberAt(SchemaString newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "BibNumber", index, newValue.ToString());
		}

		public void ReplaceBibNumberAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "BibNumber", index, newValue.ToString());
		}
		#endregion // BibNumber accessor methods

		#region BibNumber collection
        public BibNumberCollection	MyBibNumbers = new BibNumberCollection( );

        public class BibNumberCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public BibNumberEnumerator GetEnumerator() 
			{
				return new BibNumberEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class BibNumberEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public BibNumberEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.BibNumberCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetBibNumberAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // BibNumber collection

		#region CCardId accessor methods
		public static int GetCCardIdMinCount()
		{
			return 0;
		}

		public static int CCardIdMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetCCardIdMaxCount()
		{
			return 1;
		}

		public static int CCardIdMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetCCardIdCount()
		{
			return DomChildCount(NodeType.Element, "", "CCardId");
		}

		public int CCardIdCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "CCardId");
			}
		}

		public bool HasCCardId()
		{
			return HasDomChild(NodeType.Element, "", "CCardId");
		}

		public CCardIdType NewCCardId()
		{
			return new CCardIdType();
		}

		public CCardIdType GetCCardIdAt(int index)
		{
			return new CCardIdType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "CCardId", index)));
		}

		public XmlNode GetStartingCCardIdCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "CCardId" );
		}

		public XmlNode GetAdvancedCCardIdCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "CCardId", curNode );
		}

		public CCardIdType GetCCardIdValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new CCardIdType( curNode.InnerText );
		}


		public CCardIdType GetCCardId()
		{
			return GetCCardIdAt(0);
		}

		public CCardIdType CCardId
		{
			get
			{
				return GetCCardIdAt(0);
			}
		}

		public void RemoveCCardIdAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "CCardId", index);
		}

		public void RemoveCCardId()
		{
			while (HasCCardId())
				RemoveCCardIdAt(0);
		}

		public void AddCCardId(CCardIdType newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "CCardId", newValue.ToString());
		}

		public void InsertCCardIdAt(CCardIdType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "CCardId", index, newValue.ToString());
		}

		public void ReplaceCCardIdAt(CCardIdType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "CCardId", index, newValue.ToString());
		}
		#endregion // CCardId accessor methods

		#region CCardId collection
        public CCardIdCollection	MyCCardIds = new CCardIdCollection( );

        public class CCardIdCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public CCardIdEnumerator GetEnumerator() 
			{
				return new CCardIdEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class CCardIdEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public CCardIdEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.CCardIdCount );
			}
			public CCardIdType  Current 
			{
				get 
				{
					return(parent.GetCCardIdAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // CCardId collection

		#region StartTime accessor methods
		public static int GetStartTimeMinCount()
		{
			return 1;
		}

		public static int StartTimeMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetStartTimeMaxCount()
		{
			return 1;
		}

		public static int StartTimeMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetStartTimeCount()
		{
			return DomChildCount(NodeType.Element, "", "StartTime");
		}

		public int StartTimeCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "StartTime");
			}
		}

		public bool HasStartTime()
		{
			return HasDomChild(NodeType.Element, "", "StartTime");
		}

		public StartTimeType NewStartTime()
		{
			return new StartTimeType(domNode.OwnerDocument.CreateElement("StartTime", ""));
		}

		public StartTimeType GetStartTimeAt(int index)
		{
			return new StartTimeType(GetDomChildAt(NodeType.Element, "", "StartTime", index));
		}

		public XmlNode GetStartingStartTimeCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "StartTime" );
		}

		public XmlNode GetAdvancedStartTimeCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "StartTime", curNode );
		}

		public StartTimeType GetStartTimeValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new StartTimeType( curNode );
		}


		public StartTimeType GetStartTime()
		{
			return GetStartTimeAt(0);
		}

		public StartTimeType StartTime
		{
			get
			{
				return GetStartTimeAt(0);
			}
		}

		public void RemoveStartTimeAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "StartTime", index);
		}

		public void RemoveStartTime()
		{
			while (HasStartTime())
				RemoveStartTimeAt(0);
		}

		public void AddStartTime(StartTimeType newValue)
		{
			AppendDomElement("", "StartTime", newValue);
		}

		public void InsertStartTimeAt(StartTimeType newValue, int index)
		{
			InsertDomElementAt("", "StartTime", index, newValue);
		}

		public void ReplaceStartTimeAt(StartTimeType newValue, int index)
		{
			ReplaceDomElementAt("", "StartTime", index, newValue);
		}
		#endregion // StartTime accessor methods

		#region StartTime collection
        public StartTimeCollection	MyStartTimes = new StartTimeCollection( );

        public class StartTimeCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public StartTimeEnumerator GetEnumerator() 
			{
				return new StartTimeEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class StartTimeEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public StartTimeEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.StartTimeCount );
			}
			public StartTimeType  Current 
			{
				get 
				{
					return(parent.GetStartTimeAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // StartTime collection

		#region FinishTime accessor methods
		public static int GetFinishTimeMinCount()
		{
			return 1;
		}

		public static int FinishTimeMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetFinishTimeMaxCount()
		{
			return 1;
		}

		public static int FinishTimeMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetFinishTimeCount()
		{
			return DomChildCount(NodeType.Element, "", "FinishTime");
		}

		public int FinishTimeCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "FinishTime");
			}
		}

		public bool HasFinishTime()
		{
			return HasDomChild(NodeType.Element, "", "FinishTime");
		}

		public FinishTimeType NewFinishTime()
		{
			return new FinishTimeType(domNode.OwnerDocument.CreateElement("FinishTime", ""));
		}

		public FinishTimeType GetFinishTimeAt(int index)
		{
			return new FinishTimeType(GetDomChildAt(NodeType.Element, "", "FinishTime", index));
		}

		public XmlNode GetStartingFinishTimeCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "FinishTime" );
		}

		public XmlNode GetAdvancedFinishTimeCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "FinishTime", curNode );
		}

		public FinishTimeType GetFinishTimeValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new FinishTimeType( curNode );
		}


		public FinishTimeType GetFinishTime()
		{
			return GetFinishTimeAt(0);
		}

		public FinishTimeType FinishTime
		{
			get
			{
				return GetFinishTimeAt(0);
			}
		}

		public void RemoveFinishTimeAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "FinishTime", index);
		}

		public void RemoveFinishTime()
		{
			while (HasFinishTime())
				RemoveFinishTimeAt(0);
		}

		public void AddFinishTime(FinishTimeType newValue)
		{
			AppendDomElement("", "FinishTime", newValue);
		}

		public void InsertFinishTimeAt(FinishTimeType newValue, int index)
		{
			InsertDomElementAt("", "FinishTime", index, newValue);
		}

		public void ReplaceFinishTimeAt(FinishTimeType newValue, int index)
		{
			ReplaceDomElementAt("", "FinishTime", index, newValue);
		}
		#endregion // FinishTime accessor methods

		#region FinishTime collection
        public FinishTimeCollection	MyFinishTimes = new FinishTimeCollection( );

        public class FinishTimeCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public FinishTimeEnumerator GetEnumerator() 
			{
				return new FinishTimeEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class FinishTimeEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public FinishTimeEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.FinishTimeCount );
			}
			public FinishTimeType  Current 
			{
				get 
				{
					return(parent.GetFinishTimeAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // FinishTime collection

		#region Time accessor methods
		public static int GetTimeMinCount()
		{
			return 0;
		}

		public static int TimeMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTimeMaxCount()
		{
			return 1;
		}

		public static int TimeMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTimeCount()
		{
			return DomChildCount(NodeType.Element, "", "Time");
		}

		public int TimeCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Time");
			}
		}

		public bool HasTime()
		{
			return HasDomChild(NodeType.Element, "", "Time");
		}

		public TimeType NewTime()
		{
			return new TimeType();
		}

		public TimeType GetTimeAt(int index)
		{
			return new TimeType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Time", index)));
		}

		public XmlNode GetStartingTimeCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Time" );
		}

		public XmlNode GetAdvancedTimeCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Time", curNode );
		}

		public TimeType GetTimeValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new TimeType( curNode.InnerText );
		}


		public TimeType GetTime()
		{
			return GetTimeAt(0);
		}

		public TimeType Time
		{
			get
			{
				return GetTimeAt(0);
			}
		}

		public void RemoveTimeAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Time", index);
		}

		public void RemoveTime()
		{
			while (HasTime())
				RemoveTimeAt(0);
		}

		public void AddTime(TimeType newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "Time", newValue.ToString());
		}

		public void InsertTimeAt(TimeType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "Time", index, newValue.ToString());
		}

		public void ReplaceTimeAt(TimeType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Time", index, newValue.ToString());
		}
		#endregion // Time accessor methods

		#region Time collection
        public TimeCollection	MyTimes = new TimeCollection( );

        public class TimeCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public TimeEnumerator GetEnumerator() 
			{
				return new TimeEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TimeEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public TimeEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TimeCount );
			}
			public TimeType  Current 
			{
				get 
				{
					return(parent.GetTimeAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Time collection

		#region TimeDiff accessor methods
		public static int GetTimeDiffMinCount()
		{
			return 0;
		}

		public static int TimeDiffMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetTimeDiffMaxCount()
		{
			return 1;
		}

		public static int TimeDiffMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTimeDiffCount()
		{
			return DomChildCount(NodeType.Element, "", "TimeDiff");
		}

		public int TimeDiffCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TimeDiff");
			}
		}

		public bool HasTimeDiff()
		{
			return HasDomChild(NodeType.Element, "", "TimeDiff");
		}

		public TimeDiffType NewTimeDiff()
		{
			return new TimeDiffType();
		}

		public TimeDiffType GetTimeDiffAt(int index)
		{
			return new TimeDiffType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TimeDiff", index)));
		}

		public XmlNode GetStartingTimeDiffCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TimeDiff" );
		}

		public XmlNode GetAdvancedTimeDiffCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TimeDiff", curNode );
		}

		public TimeDiffType GetTimeDiffValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new TimeDiffType( curNode.InnerText );
		}


		public TimeDiffType GetTimeDiff()
		{
			return GetTimeDiffAt(0);
		}

		public TimeDiffType TimeDiff
		{
			get
			{
				return GetTimeDiffAt(0);
			}
		}

		public void RemoveTimeDiffAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TimeDiff", index);
		}

		public void RemoveTimeDiff()
		{
			while (HasTimeDiff())
				RemoveTimeDiffAt(0);
		}

		public void AddTimeDiff(TimeDiffType newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "TimeDiff", newValue.ToString());
		}

		public void InsertTimeDiffAt(TimeDiffType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "TimeDiff", index, newValue.ToString());
		}

		public void ReplaceTimeDiffAt(TimeDiffType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TimeDiff", index, newValue.ToString());
		}
		#endregion // TimeDiff accessor methods

		#region TimeDiff collection
        public TimeDiffCollection	MyTimeDiffs = new TimeDiffCollection( );

        public class TimeDiffCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public TimeDiffEnumerator GetEnumerator() 
			{
				return new TimeDiffEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TimeDiffEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public TimeDiffEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TimeDiffCount );
			}
			public TimeDiffType  Current 
			{
				get 
				{
					return(parent.GetTimeDiffAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TimeDiff collection

		#region ResultPosition accessor methods
		public static int GetResultPositionMinCount()
		{
			return 0;
		}

		public static int ResultPositionMinCount
		{
			get
			{
				return 0;
			}
		}

		public static int GetResultPositionMaxCount()
		{
			return 1;
		}

		public static int ResultPositionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetResultPositionCount()
		{
			return DomChildCount(NodeType.Element, "", "ResultPosition");
		}

		public int ResultPositionCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ResultPosition");
			}
		}

		public bool HasResultPosition()
		{
			return HasDomChild(NodeType.Element, "", "ResultPosition");
		}

		public ResultPositionType NewResultPosition()
		{
			return new ResultPositionType();
		}

		public ResultPositionType GetResultPositionAt(int index)
		{
			return new ResultPositionType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "ResultPosition", index)));
		}

		public XmlNode GetStartingResultPositionCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ResultPosition" );
		}

		public XmlNode GetAdvancedResultPositionCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ResultPosition", curNode );
		}

		public ResultPositionType GetResultPositionValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new ResultPositionType( curNode.InnerText );
		}


		public ResultPositionType GetResultPosition()
		{
			return GetResultPositionAt(0);
		}

		public ResultPositionType ResultPosition
		{
			get
			{
				return GetResultPositionAt(0);
			}
		}

		public void RemoveResultPositionAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ResultPosition", index);
		}

		public void RemoveResultPosition()
		{
			while (HasResultPosition())
				RemoveResultPositionAt(0);
		}

		public void AddResultPosition(ResultPositionType newValue)
		{
			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.Element, "", "ResultPosition", newValue.ToString());
		}

		public void InsertResultPositionAt(ResultPositionType newValue, int index)
		{
			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.Element, "", "ResultPosition", index, newValue.ToString());
		}

		public void ReplaceResultPositionAt(ResultPositionType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "ResultPosition", index, newValue.ToString());
		}
		#endregion // ResultPosition accessor methods

		#region ResultPosition collection
        public ResultPositionCollection	MyResultPositions = new ResultPositionCollection( );

        public class ResultPositionCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ResultPositionEnumerator GetEnumerator() 
			{
				return new ResultPositionEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ResultPositionEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public ResultPositionEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ResultPositionCount );
			}
			public ResultPositionType  Current 
			{
				get 
				{
					return(parent.GetResultPositionAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ResultPosition collection

		#region CompetitorStatus accessor methods
		public static int GetCompetitorStatusMinCount()
		{
			return 1;
		}

		public static int CompetitorStatusMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetCompetitorStatusMaxCount()
		{
			return 1;
		}

		public static int CompetitorStatusMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetCompetitorStatusCount()
		{
			return DomChildCount(NodeType.Element, "", "CompetitorStatus");
		}

		public int CompetitorStatusCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "CompetitorStatus");
			}
		}

		public bool HasCompetitorStatus()
		{
			return HasDomChild(NodeType.Element, "", "CompetitorStatus");
		}

		public CompetitorStatusType NewCompetitorStatus()
		{
			return new CompetitorStatusType(domNode.OwnerDocument.CreateElement("CompetitorStatus", ""));
		}

		public CompetitorStatusType GetCompetitorStatusAt(int index)
		{
			return new CompetitorStatusType(GetDomChildAt(NodeType.Element, "", "CompetitorStatus", index));
		}

		public XmlNode GetStartingCompetitorStatusCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "CompetitorStatus" );
		}

		public XmlNode GetAdvancedCompetitorStatusCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "CompetitorStatus", curNode );
		}

		public CompetitorStatusType GetCompetitorStatusValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new CompetitorStatusType( curNode );
		}


		public CompetitorStatusType GetCompetitorStatus()
		{
			return GetCompetitorStatusAt(0);
		}

		public CompetitorStatusType CompetitorStatus
		{
			get
			{
				return GetCompetitorStatusAt(0);
			}
		}

		public void RemoveCompetitorStatusAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "CompetitorStatus", index);
		}

		public void RemoveCompetitorStatus()
		{
			while (HasCompetitorStatus())
				RemoveCompetitorStatusAt(0);
		}

		public void AddCompetitorStatus(CompetitorStatusType newValue)
		{
			AppendDomElement("", "CompetitorStatus", newValue);
		}

		public void InsertCompetitorStatusAt(CompetitorStatusType newValue, int index)
		{
			InsertDomElementAt("", "CompetitorStatus", index, newValue);
		}

		public void ReplaceCompetitorStatusAt(CompetitorStatusType newValue, int index)
		{
			ReplaceDomElementAt("", "CompetitorStatus", index, newValue);
		}
		#endregion // CompetitorStatus accessor methods

		#region CompetitorStatus collection
        public CompetitorStatusCollection	MyCompetitorStatuss = new CompetitorStatusCollection( );

        public class CompetitorStatusCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public CompetitorStatusEnumerator GetEnumerator() 
			{
				return new CompetitorStatusEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class CompetitorStatusEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public CompetitorStatusEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.CompetitorStatusCount );
			}
			public CompetitorStatusType  Current 
			{
				get 
				{
					return(parent.GetCompetitorStatusAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // CompetitorStatus collection

		#region ModifyDate accessor methods
		public static int GetModifyDateMinCount()
		{
			return 1;
		}

		public static int ModifyDateMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetModifyDateMaxCount()
		{
			return 1;
		}

		public static int ModifyDateMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetModifyDateCount()
		{
			return DomChildCount(NodeType.Element, "", "ModifyDate");
		}

		public int ModifyDateCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ModifyDate");
			}
		}

		public bool HasModifyDate()
		{
			return HasDomChild(NodeType.Element, "", "ModifyDate");
		}

		public ModifyDateType NewModifyDate()
		{
			return new ModifyDateType(domNode.OwnerDocument.CreateElement("ModifyDate", ""));
		}

		public ModifyDateType GetModifyDateAt(int index)
		{
			return new ModifyDateType(GetDomChildAt(NodeType.Element, "", "ModifyDate", index));
		}

		public XmlNode GetStartingModifyDateCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ModifyDate" );
		}

		public XmlNode GetAdvancedModifyDateCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ModifyDate", curNode );
		}

		public ModifyDateType GetModifyDateValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new ModifyDateType( curNode );
		}


		public ModifyDateType GetModifyDate()
		{
			return GetModifyDateAt(0);
		}

		public ModifyDateType ModifyDate
		{
			get
			{
				return GetModifyDateAt(0);
			}
		}

		public void RemoveModifyDateAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ModifyDate", index);
		}

		public void RemoveModifyDate()
		{
			while (HasModifyDate())
				RemoveModifyDateAt(0);
		}

		public void AddModifyDate(ModifyDateType newValue)
		{
			AppendDomElement("", "ModifyDate", newValue);
		}

		public void InsertModifyDateAt(ModifyDateType newValue, int index)
		{
			InsertDomElementAt("", "ModifyDate", index, newValue);
		}

		public void ReplaceModifyDateAt(ModifyDateType newValue, int index)
		{
			ReplaceDomElementAt("", "ModifyDate", index, newValue);
		}
		#endregion // ModifyDate accessor methods

		#region ModifyDate collection
        public ModifyDateCollection	MyModifyDates = new ModifyDateCollection( );

        public class ModifyDateCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ModifyDateEnumerator GetEnumerator() 
			{
				return new ModifyDateEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ModifyDateEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public ModifyDateEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ModifyDateCount );
			}
			public ModifyDateType  Current 
			{
				get 
				{
					return(parent.GetModifyDateAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ModifyDate collection

		#region ModifiedBy accessor methods
		public static int GetModifiedByMinCount()
		{
			return 1;
		}

		public static int ModifiedByMinCount
		{
			get
			{
				return 1;
			}
		}

		public static int GetModifiedByMaxCount()
		{
			return 1;
		}

		public static int ModifiedByMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetModifiedByCount()
		{
			return DomChildCount(NodeType.Element, "", "ModifiedBy");
		}

		public int ModifiedByCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ModifiedBy");
			}
		}

		public bool HasModifiedBy()
		{
			return HasDomChild(NodeType.Element, "", "ModifiedBy");
		}

		public ModifiedByType NewModifiedBy()
		{
			return new ModifiedByType(domNode.OwnerDocument.CreateElement("ModifiedBy", ""));
		}

		public ModifiedByType GetModifiedByAt(int index)
		{
			return new ModifiedByType(GetDomChildAt(NodeType.Element, "", "ModifiedBy", index));
		}

		public XmlNode GetStartingModifiedByCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ModifiedBy" );
		}

		public XmlNode GetAdvancedModifiedByCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ModifiedBy", curNode );
		}

		public ModifiedByType GetModifiedByValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new ModifiedByType( curNode );
		}


		public ModifiedByType GetModifiedBy()
		{
			return GetModifiedByAt(0);
		}

		public ModifiedByType ModifiedBy
		{
			get
			{
				return GetModifiedByAt(0);
			}
		}

		public void RemoveModifiedByAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ModifiedBy", index);
		}

		public void RemoveModifiedBy()
		{
			while (HasModifiedBy())
				RemoveModifiedByAt(0);
		}

		public void AddModifiedBy(ModifiedByType newValue)
		{
			AppendDomElement("", "ModifiedBy", newValue);
		}

		public void InsertModifiedByAt(ModifiedByType newValue, int index)
		{
			InsertDomElementAt("", "ModifiedBy", index, newValue);
		}

		public void ReplaceModifiedByAt(ModifiedByType newValue, int index)
		{
			ReplaceDomElementAt("", "ModifiedBy", index, newValue);
		}
		#endregion // ModifiedBy accessor methods

		#region ModifiedBy collection
        public ModifiedByCollection	MyModifiedBys = new ModifiedByCollection( );

        public class ModifiedByCollection: IEnumerable
        {
            ResultType parent;
            public ResultType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ModifiedByEnumerator GetEnumerator() 
			{
				return new ModifiedByEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ModifiedByEnumerator: IEnumerator 
        {
			int nIndex;
			ResultType parent;
			public ModifiedByEnumerator(ResultType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ModifiedByCount );
			}
			public ModifiedByType  Current 
			{
				get 
				{
					return(parent.GetModifiedByAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ModifiedBy collection

        private void SetCollectionParents()
        {
            MyResultIds.Parent = this; 
            MyBibNumbers.Parent = this; 
            MyCCardIds.Parent = this; 
            MyStartTimes.Parent = this; 
            MyFinishTimes.Parent = this; 
            MyTimes.Parent = this; 
            MyTimeDiffs.Parent = this; 
            MyResultPositions.Parent = this; 
            MyCompetitorStatuss.Parent = this; 
            MyModifyDates.Parent = this; 
            MyModifiedBys.Parent = this; 
	}
}
}
